//! Zod generation library
//! 
//! Provides the `ZodSchema` trait, helper functions, and the `ZodGenerator`.

use std::collections::HashMap;

/// Trait for Rust types that can produce a Zod schema
pub trait ZodSchema {
    /// Returns the Zod schema as a string
    fn zod_schema() -> String;
    /// Returns the type name for output file naming
    fn type_name() -> String;
}

/// Helper functions for building Zod schema strings
pub fn zod_string() -> &'static str { "z.string()" }
pub fn zod_number() -> &'static str { "z.number()" }
pub fn zod_bigint() -> &'static str { "z.bigint()" }
pub fn zod_boolean() -> &'static str { "z.boolean()" }

pub fn zod_nullable(inner: &str) -> String { format!("{}.nullable()", inner) }
pub fn zod_array(inner: &str) -> String { format!("z.array({})", inner) }
pub fn zod_record(value: &str) -> String { format!("z.record(z.string(), {})", value) }

pub fn zod_object(fields: &[(&str, &str)]) -> String {
    let items: Vec<String> = fields.iter()
        .map(|(k,v)| format!("  {}: {}", k, v))
        .collect();
    format!("z.object({{\n{}\n}})", items.join(",\n"))
}

pub fn zod_enum(variants: &[&str]) -> String {
    let lits: Vec<String> = variants.iter().map(|v| format!("z.literal('{}')", v)).collect();
    format!("z.union([{}])", lits.join(", "))
}

/// Generator that collects schemas and writes TS files
pub struct ZodGenerator {
    schemas: HashMap<String,String>,
    deps: HashMap<String,Vec<String>>,
}

impl ZodGenerator {
    pub fn new() -> Self {
        Self { schemas: HashMap::new(), deps: HashMap::new() }
    }
    pub fn add_schema<T: ZodSchema>(&mut self) {
        let name = T::type_name();
        let schema = T::zod_schema();
        self.schemas.insert(name.clone(), schema);
    }
    pub fn list_types(&self) -> Vec<&String> { self.schemas.keys().collect() }
    pub fn generate_file(&self, name: &str) -> Option<String> {
        self.schemas.get(name).map(|schema| {
            format!(
r###"// Automatically generated by zod_gen
import {{ z }} from 'zod';

export const {name}Schema = {schema};
export type {name} = z.infer<typeof {name}Schema>;
"###,
                name = name,
                schema = schema
            )
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_primitives() {
        assert_eq!(zod_string(), "z.string()");
        assert_eq!(zod_number(), "z.number()");
        assert_eq!(zod_boolean(), "z.boolean()");
        assert_eq!(zod_bigint(), "z.bigint()");
    }

    #[derive(Debug)]
    struct Dummy;

    impl ZodSchema for Dummy {
        fn type_name() -> String { "Dummy".into() }
        fn zod_schema() -> String { zod_string().into() }
    }

    #[test]
    fn test_generator() {
        let mut gen = ZodGenerator::new();
        gen.add_schema::<Dummy>();
        let list = gen.list_types();
        assert_eq!(list, vec![&"Dummy".to_string()]);
        assert_eq!(gen.generate_file("Dummy").unwrap().contains("z.string()"), true);
    }
}

// Implementations for common Rust types
impl ZodSchema for String {
    fn type_name() -> String { "String".to_string() }
    fn zod_schema() -> String { zod_string().to_string() }
}

impl ZodSchema for i32 {
    fn type_name() -> String { "i32".to_string() }
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for i64 {
    fn type_name() -> String { "i64".to_string() }
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for u32 {
    fn type_name() -> String { "u32".to_string() }
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for u64 {
    fn type_name() -> String { "u64".to_string() }
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for f32 {
    fn type_name() -> String { "f32".to_string() }
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for f64 {
    fn type_name() -> String { "f64".to_string() }
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for bool {
    fn type_name() -> String { "bool".to_string() }
    fn zod_schema() -> String { zod_boolean().to_string() }
}

impl<T: ZodSchema> ZodSchema for Option<T> {
    fn type_name() -> String { format!("Option<{}>", T::type_name()) }
    fn zod_schema() -> String { zod_nullable(&T::zod_schema()) }
}

impl<T: ZodSchema> ZodSchema for Vec<T> {
    fn type_name() -> String { format!("Vec<{}>", T::type_name()) }
    fn zod_schema() -> String { zod_array(&T::zod_schema()) }
}