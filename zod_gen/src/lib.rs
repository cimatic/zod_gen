//! Zod generation library
//! 
//! Provides the `ZodSchema` trait, helper functions, and the `ZodGenerator`.

use std::collections::HashMap;

/// Trait for Rust types that can produce a Zod schema
pub trait ZodSchema {
    /// Returns the Zod schema as a string
    fn zod_schema() -> String;
}

/// Helper functions for building Zod schema strings
pub fn zod_string() -> &'static str { "z.string()" }
pub fn zod_number() -> &'static str { "z.number()" }
pub fn zod_bigint() -> &'static str { "z.bigint()" }
pub fn zod_boolean() -> &'static str { "z.boolean()" }

pub fn zod_nullable(inner: &str) -> String { format!("{}.nullable()", inner) }
pub fn zod_array(inner: &str) -> String { format!("z.array({})", inner) }
pub fn zod_record(value: &str) -> String { format!("z.record(z.string(), {})", value) }

pub fn zod_object(fields: &[(&str, &str)]) -> String {
    let items: Vec<String> = fields.iter()
        .map(|(k,v)| format!("  {}: {}", k, v))
        .collect();
    format!("z.object({{\n{}\n}})", items.join(",\n"))
}

pub fn zod_enum(variants: &[&str]) -> String {
    let lits: Vec<String> = variants.iter().map(|v| format!("z.literal('{}')", v)).collect();
    format!("z.union([{}])", lits.join(", "))
}

/// Generator that collects schemas and writes a single TS file
pub struct ZodGenerator {
    schemas: HashMap<String, String>,
}

impl ZodGenerator {
    pub fn new() -> Self {
        Self { schemas: HashMap::new() }
    }
    
    pub fn add_schema<T: ZodSchema>(&mut self, name: &str) {
        let schema = T::zod_schema();
        self.schemas.insert(name.to_string(), schema);
    }
    
    pub fn generate(&self) -> String {
        let mut output = String::from("// Automatically generated by zod_gen\nimport { z } from 'zod';\n\n");
        
        for (name, schema) in &self.schemas {
            output.push_str(&format!(
                "export const {}Schema = {};\nexport type {} = z.infer<typeof {}Schema>;\n\n",
                name, schema, name, name
            ));
        }
        
        output
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_primitives() {
        assert_eq!(zod_string(), "z.string()");
        assert_eq!(zod_number(), "z.number()");
        assert_eq!(zod_boolean(), "z.boolean()");
        assert_eq!(zod_bigint(), "z.bigint()");
    }

    #[derive(Debug)]
    struct Dummy;

    impl ZodSchema for Dummy {
        fn zod_schema() -> String { zod_string().into() }
    }

    #[test]
    fn test_generator() {
        let mut gen = ZodGenerator::new();
        gen.add_schema::<Dummy>("Dummy");
        let output = gen.generate();
        assert!(output.contains("DummySchema = z.string()"));
        assert!(output.contains("export type Dummy"));
    }

    #[test]
    fn test_generic_hashmap() {
        // Test HashMap<String, String>
        assert_eq!(
            <HashMap<String, String>>::zod_schema(),
            "z.record(z.string(), z.string())"
        );

        // Test HashMap<String, i32>
        assert_eq!(
            <HashMap<String, i32>>::zod_schema(),
            "z.record(z.string(), z.number())"
        );

        // Test HashMap<String, Option<bool>>
        assert_eq!(
            <HashMap<String, Option<bool>>>::zod_schema(),
            "z.record(z.string(), z.boolean().nullable())"
        );

        // Test HashMap<String, Vec<String>>
        assert_eq!(
            <HashMap<String, Vec<String>>>::zod_schema(),
            "z.record(z.string(), z.array(z.string()))"
        );
    }
}

// Implementations for common Rust types
impl ZodSchema for String {
    fn zod_schema() -> String { zod_string().to_string() }
}

impl ZodSchema for i32 {
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for i64 {
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for u32 {
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for u64 {
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for f32 {
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for f64 {
    fn zod_schema() -> String { zod_number().to_string() }
}

impl ZodSchema for bool {
    fn zod_schema() -> String { zod_boolean().to_string() }
}

impl<T: ZodSchema> ZodSchema for Option<T> {
    fn zod_schema() -> String { zod_nullable(&T::zod_schema()) }
}

impl<T: ZodSchema> ZodSchema for Vec<T> {
    fn zod_schema() -> String { zod_array(&T::zod_schema()) }
}

impl<T: ZodSchema> ZodSchema for HashMap<String, T> {
    fn zod_schema() -> String { zod_record(&T::zod_schema()) }
}

impl ZodSchema for serde_json::Value {
    fn zod_schema() -> String { "z.any()".to_string() }
}